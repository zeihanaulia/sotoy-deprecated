'use strict';(function(){const indexCfg={};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/about.html','title':"Ini tuh apa?",'content':"Sotoy Driven Development Seperti yang tertulis pada subdomain dan judul website SOTOY. Tulisan disini berasal dari ke SOTOY-an gw. Kalo belum tau sotoy itu apa, sotoy itu singkatan dari kalimat Sok tau loe ya.\n\u0026ldquo;Sotoy\u0026rdquo; adalah salah satu dari sekian banyak kata gaul yang belakangan ini sedang ngetrend di sosmed, berasal dari gabungan dan plesetan kata \u0026ldquo;Sok tau loe ya\u0026rdquo; yang disingkat menjadi \u0026ldquo;Sotoy\u0026rdquo;, kata ini ditujukan untuk seseorang yang punya kebiasaan sok tau.\n Apa-arti-dan-asal-kata-sotoy  Jadi intinya, semua yang ditulis disini hasil ke sok tau-an gw, jadi kalo misalnya ada kesalahan silahkan nasehatin gw supaya benar.\nTerima Kasih,\nZeihan Aulia\n"});index.add({'id':1,'href':'/categories/belajar.html','title':"belajar",'content':""});index.add({'id':2,'href':'/posts.html','title':"Blog",'content':""});index.add({'id':3,'href':'/posts/docker/cara-menggunakan-docker.html','title':"Cara menggunakan docker",'content':"Sebelumnya pernah bikin tulisan bagaimana install postgre sql menggunakan docker.\n"});index.add({'id':4,'href':'/categories.html','title':"Categories",'content':""});index.add({'id':5,'href':'/tags/docker.html','title':"docker",'content':""});index.add({'id':6,'href':'/','title':"Sotoy",'content':""});index.add({'id':7,'href':'/tags.html','title':"Tags",'content':""});index.add({'id':8,'href':'/posts/rust/mencoba-rust-system-programming-language.html','title':"Mencoba Rust System Programming Language",'content':"Sudah dari tahun 2018 kami sudah mendengar rust, terutama ketika AWS me-\u0026ldquo;Open Source\u0026rdquo; FireCraker - Engine Lambda, rust menjadi salah satu bahasa yang digadang-gadang saingan go. Ya meski tidak ada saingan diantara bahasa pemrograman, karena itu cuma alat bantu untuk menyelesaikan masalah. Baru ditahun ini ingin mencoba Rust, Karena ada kejenuhan dan ingin mencoba sesuatu yang baru.\nSekilas baca buku Programming Rust, 2nd Edition, bagian Why Rust?. Yang kami tangkap disana itu Rust adalah\n a safe, concurrent language with the performance of C and C++.\n Rust adalah bahasa yang dikembangkan oleh Mozilla dan komunitasnya. Ia adalah system programming baru. System programming itu untuk, Sistem Operasi, FileSystem, Database, Bisa jalan di device yang murah, dll. Intinya sistem programming adalahresource-constrained programming` artinya pemrograman yang benar-benar memperhatikan setiap byte dan CPU.\nKenalan dulu Instalasi Rust Instalasinya cukup mudah, hanya perlu googling sekali dan langsung ditujukan ke https://doc.rust-lang.org/book/ch01-01-installation.html.\nMencoba Rust Setelah sukses melakukan instalasi, Kita bisa mencoba, Bukan hanya rust, instalasi diatas juga memberikan Cargo sebagai package manager. Apa saja yang cargo lakukan.\ncargo --version # cargo 1.42.0 (86334295e 2020-01-31) Versi Cargo diatas terpisah dengan versi rust.\ncargo new --bin myproject Dengan syntax diatas, Cargo akan membuatkan folder yang berisi layout dari project.\n- myproject -- Cargo.toml -- src Cargo.toml berisi metadata dari project kita\n[package] name = \u0026#34;myproject\u0026#34; version = \u0026#34;0.1.0\u0026#34; authors = [\u0026#34;Zeihan Aulia \u0026lt;zeihan@warungpintar.co\u0026gt;\u0026#34;] edition = \u0026#34;2018\u0026#34; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] Disana ada 2 bagian yaitu [package] dan [dependencies]. Package adalah metadata dari project. Dependencies adalah list library dependency yang kita gunakan.\nDidalam folder src, terdapat main.rs. didalamnya tertulis kode hello world. Selanjutnya kita build project tersebut dengan menggunakan syntax\ncargo build # Compiling myproject v0.1.0 (/Users/zeihanaulia/Programming/research/rust-learning/myproject) # Finished dev [unoptimized + debuginfo] target(s) in 1.62s Jika build berhasil, maka kita akan mendapatkan folder baru yaitu target yang didalamnya berisi folder debug. Yang didalamnya terdapat binary dari hasil build kita.\n./target/debug/myproject # Hello, world! Kalau kita ingin melakukan analisis dari runtime performance dari kode kita. Pastikan kita melakukan build dengan\ncargo build --release # Compiling myproject v0.1.0 (/Users/zeihanaulia/Programming/research/rust-learning/myproject) # Finished release [optimized] target(s) in 0.92s dan mejalankannya\n./target/release/myproject # Hello, world! Pada phase development dari pada menggunakan build, kita bisa menggunakan\ncargo run Variable Variable di rust sama seperti variable pada umumnya dibahasa pemrograman lain yang mana variable dapat meletakan isi disebuah wadah.\nGimana sih cara declare variable? let x = 5; Variable dimulai dengan kata kunci let dan dilanjutkan dengan x sebagai nama dari variable. Selanjutya isi vairable x dengan menggunakan = lalu nilainya 5, jangan lupa ditutup dengan semicolon ;.\nfn main() { let x = 5; let y = 6; let z = x + y ; println!(\u0026#34;z is {}\u0026#34;, z) } Coba disini.\nRust itu defaultnya mutable loh. Perbedaan variable rust dibanding yang bahasa lain adalah mutable by default.\nfn main() { let x = 5; x += 1; println!(\u0026#34;x is now {}\u0026#34;, x); } hasilnya\nCompiling playground v0.0.1 (/playground) error[E0384]: cannot assign twice to immutable variable `x` --\u0026gt; src/main.rs:3:5 | 2 | let x = 5; | - | | | first assignment to `x` | help: make this binding mutable: `mut x` 3 | x += 1; | ^^^^^^ cannot assign twice to immutable variable error: aborting due to previous error For more information about this error, try `rustc --explain E0384`. error: could not compile `playground`. To learn more, run the command again with --verbose. Coba disini.\nKita tidak diizinkan untuk mengubah value dari dari x. Jadi untuk mengubah nilai dari suatu variable harus menggunakan kata kunci tambahan mut.\nfn main() { let mut x = 5; x += 1; println!(\u0026#34;x is now {}\u0026#34;, x); } Coba disini.\nSemua variable bisa memiliki type fn main() { let mut x: i32 = 5; } dengan menambahkan colon atau titik dua kita bisa memberikan tipe pada suatu variable.\nData Types Data types di rust dibagi menjadi 2 bagian. Simple dan Compound.\nSingle  Bool Integer Floating point Charecter  Boolean Boolean disebut bool. Isinya hanya true atau false. Boolean biasanya digunakan pada kondisi kontrol flow seperti if dan while.\nfn main() { let a = true; let b = false; if a { println!(\u0026#34;a is true!\u0026#34;) } if b { println!(\u0026#34;b is false!\u0026#34;) } } Integer Number tanpa decimal disebut dengan interger. Ada dua type Signed dan Unsigned. Sebagai tambahan kita dapat memutuskan berapa banyak space integer yang akan digunakan.\n   Signed Unsigned     i8 u8   i16 u16   i32 u32   i64 u64    Floating Number dengan decimal point.\nCharacter Compund Tuple Tuple menungkinkan kita mengelompokan beberapa nilai secara bersamaan dalam (). Nilai didalamnya tidak harus dengan nilai yang sama.\n// structuring let tup = (1, \u0026#39;c\u0026#39;, true); // descructuring  ley (x, y, z) = tup; Array Array adalah koleksi dimana semua elemen memiliki tipe yang sama.\nfn main() { let a = [0.0, 3.14, -8.8722] let second = a[1]; println!(\u0026#34;{}\u0026#34;, second) } bisa juga kita ganti nilai didalam array, dengan menambah kata kunci mut\nfn main() { let mut a = [0.0, 3.14, -8.8722] let a[0] = 1.1; println!(\u0026#34;{}\u0026#34;, second) } Tapi kita tidak bisa menambah atau mengurangi jumlah dari array\nfn main() { let mut a = [0.0, 3.14, -8.8722] let a += 1.1; println!(\u0026#34;{}\u0026#34;, second) } Slices Slice memberikan kita referesnsi sekumpulan data yang bedekatan dalam structur data lain.\nlet a = [100,200, 300] let b = \u0026amp;a[0..1] Function Sama seperti function di bahasa lain.\nfunc name(param1: type1, ...) -\u0026gt; return_type { ...body... } name(param1: type, ...) name dapat diisi dengan nama function dan bisa diisi dengan parameter. lalu diakhiri dengan result.\ncontoh function :\nfn next_birthday(name: \u0026amp;str, current_age: u8) { let next_age = current_age + 1; println!(\u0026#34;Hi {}, on your next birthdat, yuu\u0026#39;ll be {}!\u0026#34;, name, next_age) } fn main() { next_birthday(\u0026#34;Jake\u0026#34;, 33); next_birthday(\u0026#34;Vivian\u0026#34;, 0); } Coba disini.\nFunction dengan return value\nfn square(num: i32) -\u0026gt; i32 { num * num } fn main() { println!(\u0026#34;The answer is {}\u0026#34;, square(3)); } Coba disini\nUniknya return value bisa saja tanpa menggunakan kata kunci return dan tanpa diakhiri semicolon ;. Tapi kalau mau pake return juga bisa, dan harus diakhiri dengan semicolon.\nSumber Bacaan:  Programming Rust, 2nd Edition Rust in Motion The Rust Programming Language  "});index.add({'id':9,'href':'/tags/rust.html','title':"rust",'content':""});index.add({'id':10,'href':'/tags/go.html','title':"go",'content':""});index.add({'id':11,'href':'/tags/golang.html','title':"golang",'content':""});index.add({'id':12,'href':'/posts/golang/migrasi-database.html','title':"Migrasi database dengan golang",'content':"Akhir akhir ini terasa capek ketika membuat schema database langsung menggunakan GUI. Dan schema yang berubah bisa kadang kehilangan sejarahnya, kapan perubahannya tidak terawasi. Bagaimana jika skema database disatukan dengan source code aplikasi kita. Sehingga perkembangan skema database dapat tercatat sama seperti code.\nDengan tools bernama migrate menjadi solusi untuk permasalahan diatas. alih alih kita langsung membuat tabel diGUI database, kita bikin dalam script yang nantinya dimasukan kedalam database juga.\nInstall Golang Migrate Untuk pengguna mac os:\nbrew install golang-migrate Membuat file migrate migrate create -ext sql -dir postgres/migrations create_categories migrate create -ext sql -dir postgres/migrations create_products Kode diatas akan membuat file seperti ini\n20200208175630_create_categories.down.sql 20200208175630_create_categories.up.sql 20200208175630_create_products.down.sql 20200208175630_create_products.up.sql Bagian .up akan diisi dengan syntak CREATE table misal,\nCREATE SEQUENCE categories_id_seq; CREATE TABLE categories ( id INTEGER NOT NULL DEFAULT nextval(\u0026#39;categories_id_seq\u0026#39;), parent_id INTEGER, name VARCHAR(255) NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL, created_by INTEGER NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL, updated_by INTEGER , deleted_at TIMESTAMP WITH TIME ZONE DEFAULT NULL, deleted_by INTEGER, PRIMARY KEY (id) ); ALTER SEQUENCE categories_id_seq OWNED BY categories.id; CREATE SEQUENCE products_id_seq; CREATE TABLE products ( id INTEGER NOT NULL, category_id INTEGER NOT NULL, sku VARCHAR(255) NOT NULL, name VARCHAR(255) NOT NULL, price NUMERIC NOT NULL, margin NUMERIC NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL, created_by INTEGER NOT NULL, updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL, updated_by INTEGER , deleted_at TIMESTAMP WITH TIME ZONE DEFAULT NULL, deleted_by INTEGER, PRIMARY KEY (id), FOREIGN KEY (category_id) REFERENCES categories (id) ); ALTER SEQUENCE products_id_seq OWNED BY products.id; sedangkan bagian .down akan diisi dengan DROP TABLE\nDROP TABLE categories; DROP TABLE products; Setelah itu tinggal jalankan command,\nmigrate -path \u0026#34;repositories/postgres/migrations\u0026#34; -database \u0026#34;$DATA_SOURCE_NAME\u0026#34; up / down Selesai.\n"});index.add({'id':13,'href':'/tags/postgre.html','title':"postgre",'content':""});index.add({'id':14,'href':'/posts/docker/docker-postgres.html','title':"Install postgre pakai docker",'content':"Docker saat ini sudah menjadi normal yang baru dalam pengembangan perangkat lunak. Docker mempermudah kita sebagai pengembang dalam melakukan instalasi aplikasi. Teringat jaman dulu waktu awal-awal mengembangkan perangkat lunak, Harus menginstall sepertangkat pake aplikasi seperti XAMP atau LAMP untuk mempermudah instalasi.\nSekarang tidak perlu lagi, cukup menggunakan docker kita bisa menginstallnya.\nInstalling Postgre SQL Untuk mendapatkan docker images container cukup mudah dengan code.\ndocker pull postgres kode diatas akan mendownload postgre versi terakhir, kalau ingin versi yang spesifik bisa menggunakan code ini:\ndocker pull postgres:9.6.17-alpine kode tambahan :9.6.17-alpine adalah versi dari postgre yang ingin diinstall. Untuk melihat versi selengkapnya bisa lihat di https://hub.docker.com.\nMenyimpan data yang ada dipostgre Yang namanya database pasti akan ada data yang disimpan, kita tidak boleh menyimpan data didalam kontainer. Kenapa? Kontainer itu sifatnya sementara dia dapat dimatikan dan digantikan. Sedangkan datanya tidak boleh hilang. Cara untuk menyimpan data dalam hardisk komputer kita dengan menggunakan volumes\nBikin folder tempat dimana data akan disimpan\nmkdir docker/volumes/postgres Jalankan kontainer\ndocker run -p 5432:5432 \\  --name pgsql-docker \\  -v $HOME/docker/volumes/postgres:/var/lib/postgresql/data \\  -e POSTGRES_PASSWORD=postgres \\  -d postgres Untuk mengaksesnya mudah saja hanya perlu akses menggunakan data source name\npsql -h localhost -U postgres -d postgres Menginstall PgAdmin sebagai GUI postgre pada docker Kalau sebelumnya kita mengakses dengan psql atau konek menggunakan source code aplikasi kita. Sekarang kita coba menginstal GUI untuk postgre yaitu PgAdmin. Caranya mirim seperti menginstall postgre.\nDidownload dulu PgAdminnya\ndocker pull dpage/pgadmin4Lalu jalan kan kontainer\ndocker run -p 80:80 \\  -e \u0026#39;PGADMIN_DEFAULT_EMAIL=user@domain.com\u0026#39; \\  -e \u0026#39;PGADMIN_DEFAULT_PASSWORD=SuperSecret\u0026#39; \\  -d dpage/pgadmin4 Akses localhost pada browser maka kita akan ditampilkan halaman login, dimana user dan passwordnya sudah kita buat ketika menjalankan pgadmin\n-e \u0026#39;PGADMIN_DEFAULT_EMAIL=user@domain.com\u0026#39; \\ -e \u0026#39;PGADMIN_DEFAULT_PASSWORD=SuperSecret\u0026#39; \\ Untuk mengakses databasenya ada sedikit perbedaan, kita tidak bisa menggunakan localhost seperti ketika kita mencoba konek menggunakan psql yang ada dikomputer kita. Kita dapat mengakses dengan menggunakan ip dari container, caranya\ndocker inspect pgsql-docker maka akan mengasilkan list berupa json, kita fokus saja pada bagian NetworkSettings\n\u0026#34;NetworkSettings\u0026#34;: { ... \u0026#34;IPAddress\u0026#34;: \u0026#34;172.17.0.2\u0026#34;, ... } Kita dapat menggunakan ip 172.17.0.2 sebagai host pada PgAdmin. Dan sebenarnya sudah ada dokumentasinya disini\nSelesai.\n"});index.add({'id':15,'href':'/tags/graphql.html','title':"graphql",'content':""});index.add({'id':16,'href':'/posts/graphql/graphql-pagination.html','title':"Memahami GraphQL Pagination",'content':"Implementasi pagination atau bahasa indonesianya pemberian halaman pada data cukup berbeda. Biasanya cuma bikin ?page=1\u0026amp;limit=10 dimana pada query databasenya menjadi OFFSET 0 LIMIT 1. Pada GraphQL ada beberapa cara untuk melakukan pagination.\nSumber Bacaan:\n BEST PRACTICES - Pagination- Paginating results with GraphQL  "});index.add({'id':17,'href':'/posts/graphql/graphql-multiple-result-for-error-handling.html','title':"Membuat Aplikasi Pencatatan Keuangan dengan Golang dan GraphQL",'content':"GraphQL di tahun 2020 sudah menjadi normal baru didunia pengembangan perangkat lunak. Alat-alat atau pustaka untuk membangun GraphQL server sudah banyak sekali ada dibermacam-macam bahasa pemrogaman juga. Di tutorial kali ini, saya akan coba untuk membangun aplikasi menggunakan GraphQL sebagai penyedia datanya. Aplikasi yang akan dibangun adalah aplikasi pencatatan keuangan pribadi.\nGqlgen Gqlgen adalah salah satu pustaka yang dapat membantu kita membangun GraphQL Server.\nMemperpersiapkan Proyek $ mkdir cawang $ cd cawang $ go mod init github.com/zeihanaulia/cawang $ go get github.com/99designs/gqlgen Buatlah folder dengan nama cawang. Cawang adalah nama dari aplikasinya singkatan dari catat uang. Masuk kedalam folder cawang. Lalu lakukan inisiasi untuk go modules karena aplikasi ini dibuat dengan bahasa go. Dan terakhir kita unduh gqlgen dengan menggunakan go get\nMembangun GraphQL Server $ go run github.com/99designs/gqlgen init inisiasi gqlgen dan secara otomatis akan menghasilkan tata letak paket go. file apa saja yang didapat?\n folder graph tempat dimana kode yang berhubungan dengan graphql diletakan gqlgen.yml file config yang dapat digunakan untuk pengaturan tata letak gqlgen server.go file yang digunakan untuk menjalankan server graphql  Persiapan aplikasi Untuk membangun aplikasi yang kita ingin kan, kita kosongkan isi dari folder graph Untuk membuat pencatatan keuangan sederhana tipe diperlukan, Pengguna, Rekening dan Transaksi\nPengguna dapat membuat Rekening yang akan dicatat didalam Transaksi\nBudi ingin mencatat keuangannya, yang dia ingin catat\n Uang masuk atau keluar? atau perpindahan rekening (misal dari saldo bank BCA ke GoPay) Jumlah nominal uang yang dikeluarkan Kategori Pengeluaran (Makanan, Transportasi, Belanja Bulanan, dll) Menggunakan sumber uang dari rekening mana? (Bank atau cash atau gopay) Tanggal dan jam transaksi terjadi Keterangan  Untuk tahap awal sepertinya cerita diatas cukup sederhana dan bisa dilakukan pengembangan.\nBuat skema berdasarkan cerita diatas. Lalu jalankan kode, untuk mengasilkan file baru\n$ go run github.com/99designs/gqlgen -v Kita perlu mengubah sedikit pada aturan standar gqlgen.yml dengan mendeklarasikan type mapping antara graphql dan go type system. Tapi sebelum itu, kita pindahkan dulu model yang sudah dihasilkan ke file tersendiri. Kenapa?\nMekanisme dari menjalankan go run github.com/99designs/gqlgen adalah menghapus dan menghasilkan lagi models_gen.go. Sehingga ketika kita melakukan type mapping akan gagal karena modelnya tidak ada.\nSekarang sudah banyak nih resolvernya, ada accountResolver, mutationResolver, queryResolver, transactionResolver dan userResolver.\nmutationResolver dan queryResolver adalah default dari GraphQL, bisa dibilang sebagai pintu masuknya. Jika ingin memutasi (create, update, delete) dapat menggunakan mutationResolver. Jika ingin meminta darta (read) dapat menggunakan queryResolver.\nLalu accountResolver, transactionResolver dan userResolver ini apa? resolver ini yang akan mengeluarkan data dari type logika bisnis. Seperti yang kita tau, aplikasi kita ada 3 domain yaitu Account, Transaction dan User. Karena pada skema mendefinikan relasi. Maka kita dapat resolver tambahan yang mencerminkan logika bisnis.\ntype Account { id: ID! type: TypeOfAccount! name: String! bank: String balance: Float! balanceMinimum: Float Description: String transactions: [Transaction] user: User! } Jika dilihat dari skema diatas, maka generator akan menghasilkan:\nfunc (r *accountResolver) Transactions(ctx context.Context, obj *model.Account) ([]*model.Transaction, error) { panic(fmt.Errorf(\u0026#34;not implemented\u0026#34;)) } func (r *accountResolver) User(ctx context.Context, obj *model.Account) (*model.User, error) { panic(fmt.Errorf(\u0026#34;not implemented\u0026#34;)) } func (r *Resolver) Account() generated.AccountResolver { return \u0026amp;accountResolver{r} } type accountResolver struct{ *Resolver } "});index.add({'id':18,'href':'/categories/tutorial.html','title':"tutorial",'content':""});index.add({'id':19,'href':'/docs.html','title':"Docs",'content':""});})();